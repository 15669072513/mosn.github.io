"use strict";(self.webpackChunklayotto_docusaurus=self.webpackChunklayotto_docusaurus||[]).push([[1617],{1602:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(4848),o=n(8453);const i={},a="Layotto Source Parsing \u2014 WebAssembly",s={permalink:"/mosn.github.io/layotto/en-US/blog/code/webassembly",editUrl:"https://github.com/mosn/layotto/edit/main//i18n/en-US/docusaurus-plugin-content-blog/code/webassembly/index.md",source:"@site/i18n/en-US/docusaurus-plugin-content-blog/code/webassembly/index.md",title:"Layotto Source Parsing \u2014 WebAssembly",description:"This paper mainly analyses the relevant implementation and application of Layotto Middle WASM.",date:"2024-06-27T06:38:29.000Z",tags:[],readingTime:17.83,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,prevItem:{title:"Source parsing layotto startup process",permalink:"/mosn.github.io/layotto/en-US/blog/code/start_process/start_process"}},l={authorsImageUrls:[]},c=[{value:"General description",id:"general-description",level:2},{value:"Source analysis",id:"source-analysis",level:2},{value:"Frame INIT",id:"frame-init",level:3},{value:"Workflow",id:"workflow",level:3},{value:"FaaS Mode",id:"faas-mode",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:3}];function u(t){const e={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"This paper mainly analyses the relevant implementation and application of Layotto Middle WASM."}),"\n",(0,r.jsxs)(e.p,{children:["by\uff1a",(0,r.jsx)(e.a,{href:"https://github.com/rayowang",children:"\u738b\u5fd7\u9f99"})," | 18 May 2022"]}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#overview",children:"\u6982\u8ff0"})}),"\n",(0,r.jsxs)(e.li,{children:["[\u6e90\u7801\u5206\u6790](#source analysis)","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"[\u6846\u67b6INIT](#Frame INIT)"}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#workflow",children:"\u5de5\u4f5c\u6d41\u7a0b"})}),"\n",(0,r.jsx)(e.li,{children:"[FaaS\u6a21\u5f0f](#FaaS mode)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#summary",children:"\u603b\u7ed3"})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"general-description",children:"General description"}),"\n",(0,r.jsxs)(e.p,{children:["WebAssemly Abbreviations WASM, a portable, small and loaded binary format operating in sandboxing implementation environment, was originally designed to achieve high-performance applications in web browsers, benefiting from its good segregation and security, multilingual support, cool-start fast flexibility and agility and application to embed other applications for better expansion, and obviously we can embed it into Layotto.Layotto supports loading compiled WASM files and interacting with the Target WASM API via proxy_abi_version_0_2_0;\nother Layotto also supports loading and running WASM carrier functions and supports interfaces between Function and access to infrastructure; and Layotto communities are also exploring the compilation of components into WASM modules to increase segregation between modules.\u672c\u6587\u4ee5 Layotto \u5b98\u65b9 ",(0,r.jsx)(e.a,{href:"https://mosn.io/layotto/#/zh/start/wasm/start",children:"quickstart"})," \u5373\u8bbf\u95eeredis\u76f8\u5173\u793a\u4f8b\u4e3a\u4f8b\u6765\u5206\u6790 Layotto \u4e2d WebAssemly \u76f8\u5173\u7684\u5b9e\u73b0\u548c\u5e94\u7528\u3002"]}),"\n",(0,r.jsx)(e.h2,{id:"source-analysis",children:"Source analysis"}),"\n",(0,r.jsx)(e.p,{children:"Note\uff1ais based on commit hash\uff1af1cf350a52b5a1a0b3788a31681007a056e332ef"}),"\n",(0,r.jsx)(e.h3,{id:"frame-init",children:"Frame INIT"}),"\n",(0,r.jsx)(e.p,{children:"As the bottom layer of Layotto is Mosn, the WASM extension framework is also the WASM extension framework that reuses Mosn, as shown in figure 1 Layotto & Mosn WASM framework [1]."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"https://gw.alipaayobjects.com/md/rms_5891a1/afts/img/A*jz4BSJmVQ3gAAAAAAAAAAAAAAAAAAARQAQAQAQ",alt:"mosn_wasm_ext_framework_module"})}),"\n",(0,r.jsx)("center",{children:"Figure 1 Layotto & Mosn WASM framework "}),"\n",(0,r.jsx)(e.p,{children:"Among them, Manager is responsible for managing and dynamically updating WASM plugins;VM for managing WASM virtual machines, modules and instances;ABI serves as the application binary interface to provide an external interface [2]."}),"\n",(0,r.jsxs)(e.p,{children:["Here a brief review of the following concepts\uff1a",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.a,{href:"https://github.com/proxy-waste",children:"Proxy-Wasm"})," \uff1aWebAssembly for Proxies (ABI specification) is an unrelated ABI standard that defines how proxy and WASM modules interact [3] in functions and callbacks.\n",(0,r.jsx)(e.a,{href:"https://github.com/tetratelabs/proxy-wasm-go-sdk",children:"proxy-wasm-go-sdk"})," \uff1adefines the interface of function access to system resources and infrastructure services based on ",(0,r.jsx)(e.a,{href:"https://github.com/proxy-wasm/speci",children:"proxy-wasm/spec"})," which brings together the Runtime API to increase access to infrastructure.",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.a,{href:"https://github.com/mosn/proxy-waste-go-host",children:"proxy-wasm-go-host"})," WebAssembly for Proxies (GoLang host implementation)\uff1aProxy-Wasm golang implementation to implement Runtime ABI logic in Layotto.",(0,r.jsx)(e.br,{}),"\n","VM\uff1aVirtual Machine \u865a\u62df\u673a\uff0cRuntime\u7c7b\u578b\u6709\uff1awasmtime\u3001Wasmer\u3001V8\u3001 Lucet\u3001WAMR\u3001wasm3\uff0c\u672c\u6587\u4f8b\u5b50\u4e2d\u4f7f\u7528 wasmer"]}),"\n",(0,r.jsxs)(e.p,{children:["1, see first the configuration of stream filter in ",(0,r.jsx)(e.a,{href:"https://mosn.io/layotto/#/start/waste/start",children:"quickstart\u4f8b\u5b50"})," as follows, two WASM plugins can be seen, using waste VM to start a separate instance with configuration\uff1a below"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:' "stream_filters": [\n            LO\n              "type": "Layotto",\n              "config": API\n                "Function1": LOs\n                  "name": "function1", // Plugin name\n                  "instance_num": 1, // Number of sandbox instances\n                  "vm_config": LO\n                    "engine": "waste", // Virtual Machine Type Runtime Type\n                    "path": "demo/faas/code/golang/client/function_1. asm" /waste file path\n                  }\n                },\n                "Function2": LO\n                  "name": "function2", // Plugin name\n                  "instance_num": 1, // Number of sandbox instances\n                  "vm_config": LO\n                    "engine": "waste", // Virtual Machine Type Runtime Type\n                    "path": "demo/faas/code/golang/server/function_2. asm" /wasm file path\n                  }\n                }\n              }\n            }\n]\n'})}),"\n",(0,r.jsx)(e.p,{children:"The primary logic in the configuration above is to receive HTTP requests, then call function2 through ABI, and return function2 as detailed below in code\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func (Ctx *pHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action Led\n\t/1. get request body\n\tbody, err := proxywasm. etHttpRequestBody(0, bodySize)\n\tif err != nil L/\n\t\tproxywasm.LogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturn types. ctionPause\n\t}\n\n\t/2. parse request param\n\tbookName, err := getQueryParam(string(body), "name")\n\tif err != nil Led\n\t\tproxywasm. ogErrorf("param not found: %v", err)\n\t\treturns types. ctionPause\n\t}\n\n\t/3. Request function2 through ABI\n\tinventories, err := proxywasm. nvokeService("id_2", "", bookName)\n\tif err != nil LO\n\t\tproxywasm.Logrorf("invoke service failed: %v", err)\n\t\treturn types. ctionPause\n\t}\n\n\t/4. return result\n\tproxywasm. ppendHttpResponseBody([]byte ("There are " + inventories + " inventories for " + bookName + ".")\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"Function2 Primary logic is to receive HTTP requests, then call redisis through ABI and return to redis, as shown below in code\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func (Ctx *pHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action 6\n\t//1. get requested body\n\tbody, err := proxywasm.GetHttpRequestBody(0, bodySize)\n\tif err != nil Led\n\t\tproxywasm. ogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturns types.ActionPause\n\t}\n\tbookName:= string(body)\n\n\t/ 2. get request state from redis by specific key through ABI\n\tinventories, err := proxywastem. etState("redis", bookName)\n\tif err != nil LO\n\t\tproxywasm.LogErrorf("GetState failed: %v", err)\n\t\treturns types. ctionPause\n\t}\n\n\t/ 3. return result\n\tproxywasm.AppendHttpResponseBody([]byte(inventories))\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"The Manager component of the Frame 1 WASM is initialized at Mosn filter Init stage as shown below in code\uff1a"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'// Create a proxy factory for WasmFilter\nfunc createProxyWasmFilterFactory(confs map[string]interface{}) (api.StreamFilterChainFactory, error) {\n\tfactory := &FilterConfigFactory{\n\t\tconfig:        make([]*filterConfigItem, 0, len(confs)),\n\t\tRootContextID: 1,\n\t\tplugins:       make(map[string]*WasmPlugin),\n\t\trouter:        &Router{routes: make(map[string]*Group)},\n\t}\n\n\tfor configID, confIf := range confs {\n\t\tconf, ok := confIf.(map[string]interface{})\n\t\tif !ok {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory config not a map, configID: %s", configID)\n\t\t\treturn nil, errors.New("config not a map")\n\t\t}\n\t\t// \u89e3\u6790 wasm filter \u914d\u7f6e\n\t\tconfig, err := parseFilterConfigItem(conf)\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to parse config, configID: %s, err: %v", configID, err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar pluginName string\n\t\tif config.FromWasmPlugin == "" {\n\t\t\tpluginName = utils.GenerateUUID()\n            \n\t\t\t// \u6839\u636e stream filter \u7684\u914d\u7f6e\u521d\u59cb\u5316 WASM \u63d2\u4ef6\u914d\u7f6e\uff0cVmConfig \u5373 vm_config\uff0cInstanceNum \u5373 instance_num\n\t\t\tv2Config := v2.WasmPluginConfig{\n\t\t\t\tPluginName:  pluginName,\n\t\t\t\tVmConfig:    config.VmConfig,\n\t\t\t\tInstanceNum: config.InstanceNum,\n\t\t\t}\n            \n\t\t\t// WasmManager \u5b9e\u4f8b\u901a\u8fc7\u7ba1\u7406 PluginWrapper \u5bf9\u8c61\u5bf9\u6240\u6709\u63d2\u4ef6\u7684\u914d\u7f6e\u8fdb\u884c\u7edf\u4e00\u7ba1\u7406\uff0c\u63d0\u4f9b\u589e\u5220\u67e5\u6539\u80fd\u529b\u3002\u4e0b\u63a53\n\t\t\terr = wasm.GetWasmManager().AddOrUpdateWasm(v2Config)\n\t\t\tif err != nil {\n\t\t\t\tconfig.PluginName = pluginName\n\t\t\t\taddWatchFile(config, factory)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\taddWatchFile(config, factory)\n\t\t} else {\n\t\t\tpluginName = config.FromWasmPlugin\n\t\t}\n\t\tconfig.PluginName = pluginName\n\n\t\t// PluginWrapper \u5728\u4e0a\u9762\u7684 AddOrUpdateWasm \u4e2d\u5bf9\u63d2\u4ef6\u53ca\u914d\u7f6e\u8fdb\u884c\u5c01\u88c5\u5b8c\u6210\u521d\u59cb\u5316\uff0c\u8fd9\u91cc\u6839\u636e\u63d2\u4ef6\u540d\u4ece sync.Map \u62ff\u51fa\uff0c\u4ee5\u7ba1\u7406\u5e76\u6ce8\u518c PluginHandler\n\t\tpw := wasm.GetWasmManager().GetWasmPluginWrapperByName(pluginName)\n\t\tif pw == nil {\n\t\t\treturn nil, errors.New("plugin not found")\n\t\t}\n\n\t\tconfig.VmConfig = pw.GetConfig().VmConfig\n\t\tfactory.config = append(factory.config, config)\n\n\t\twasmPlugin := &WasmPlugin{\n\t\t\tpluginName:    config.PluginName,\n\t\t\tplugin:        pw.GetPlugin(),\n\t\t\trootContextID: config.RootContextID,\n\t\t\tconfig:        config,\n\t\t}\n\t\tfactory.plugins[config.PluginName] = wasmPlugin\n\t\t// \u6ce8\u518c PluginHandler\uff0c\u4ee5\u5bf9\u63d2\u4ef6\u7684\u751f\u547d\u5468\u671f\u63d0\u4f9b\u6269\u5c55\u56de\u8c03\u80fd\u529b\uff0c\u4f8b\u5982\u63d2\u4ef6\u542f\u52a8 OnPluginStart\u3001\u66f4\u65b0 OnConfigUpdate\u3002\u4e0b\u63a54\n\t\tpw.RegisterPluginHandler(factory)\n\t}\n\n\treturn factory, nil\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"3 Corresponding to Figure 1 WASM frame, NewWasmPlugin, for creating initialization of the WASM plugin, where VM, Module and Instance refer to virtual machines, modules and instances in WASM, as shown below in code\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func NewWasmPlugin(wasmConfig v2.WasmPluginConfig) (types.WasmPlugin, error) {\n\t// check instance num\n\tinstanceNum := wasmConfig.InstanceNum\n\tif instanceNum <= 0 {\n\t\tinstanceNum = runtime.NumCPU()\n\t}\n\n\twasmConfig.InstanceNum = instanceNum\n\n\t// \u6839\u636e\u914d\u7f6e\u83b7\u53d6 wasmer \u7f16\u8bd1\u548c\u6267\u884c\u5f15\u64ce\n\tvm := GetWasmEngine(wasmConfig.VmConfig.Engine)\n\tif vm == nil {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to get wasm engine: %v", wasmConfig.VmConfig.Engine)\n\t\treturn nil, ErrEngineNotFound\n\t}\n\n\t// load wasm bytes\n\tvar wasmBytes []byte\n\tif wasmConfig.VmConfig.Path != "" {\n\t\twasmBytes = loadWasmBytesFromPath(wasmConfig.VmConfig.Path)\n\t} else {\n\t\twasmBytes = loadWasmBytesFromUrl(wasmConfig.VmConfig.Url)\n\t}\n\n\tif len(wasmBytes) == 0 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to load wasm bytes, config: %v", wasmConfig)\n\t\treturn nil, ErrWasmBytesLoad\n\t}\n\n\tmd5Bytes := md5.Sum(wasmBytes)\n\tnewMd5 := hex.EncodeToString(md5Bytes[:])\n\tif wasmConfig.VmConfig.Md5 == "" {\n\t\twasmConfig.VmConfig.Md5 = newMd5\n\t} else if newMd5 != wasmConfig.VmConfig.Md5 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin the hash(MD5) of wasm bytes is incorrect, config: %v, real hash: %s",\n\t\t\twasmConfig, newMd5)\n\t\treturn nil, ErrWasmBytesIncorrect\n\t}\n\n\t// \u521b\u5efa WASM \u6a21\u5757\uff0cWASM \u6a21\u5757\u662f\u5df2\u88ab\u7f16\u8bd1\u7684\u65e0\u72b6\u6001\u4e8c\u8fdb\u5236\u4ee3\u7801\n\tmodule := vm.NewModule(wasmBytes)\n\tif module == nil {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to create module, config: %v", wasmConfig)\n\t\treturn nil, ErrModuleCreate\n\t}\n\n\tplugin := &wasmPluginImpl{\n\t\tconfig:    wasmConfig,\n\t\tvm:        vm,\n\t\twasmBytes: wasmBytes,\n\t\tmodule:    module,\n\t}\n\n\tplugin.SetCpuLimit(wasmConfig.VmConfig.Cpu)\n\tplugin.SetMemLimit(wasmConfig.VmConfig.Mem)\n\n\t// \u521b\u5efa\u5305\u542b\u6a21\u5757\u548c\u8fd0\u884c\u65f6\u72b6\u6001\u7684\u5b9e\u4f8b\uff0c\u503c\u5f97\u5173\u6ce8\u7684\u662f\uff0c\u8fd9\u91cc\u6700\u7ec8\u4f1a\u8c03\u7528 proxywasm.RegisterImports \u6ce8\u518c\u7528\u6237\u5b9e\u73b0\u7684 Imports \u51fd\u6570\uff0c\u6bd4\u5982\u793a\u4f8b\u4e2d\u7684 proxy_invoke_service \u548c proxy_get_state\nactual := plugin.EnsureInstanceNum(wasmConfig.InstanceNum)\n\tif actual == 0 {\n\t\tlog.DefaultLogger.Errorf("[wasm][plugin] NewWasmPlugin fail to ensure instance num, want: %v got 0", instanceNum)\n\t\treturn nil, ErrInstanceCreate\n\t}\n\n\treturn plugin, nil\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"Corresponding to ABI components in Figure 1 WASM frames, the OnPluginStart method calls proxy-wasm-go-host corresponding to ABI Exports and Imports etc."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'// Execute the plugin of FilterConfigFactory\nfunc (f *FilterConfigFactory) OnPluginStart(plugin types.WasmPlugin) {\n\tplugin.Exec(func(instance types.WasmInstance) bool {\n\t\twasmPlugin, ok := f.plugins[plugin.PluginName()]\n\t\tif !ok {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to get wasm plugin, PluginName: %s",\n\t\t\t\tplugin.PluginName())\n\t\t\treturn true\n\t\t}\n        \n\t\t// \u83b7\u53d6 proxy_abi_version_0_2_0 \u7248\u672c\u7684\u4e0e WASM \u4ea4\u4e92\u7684 API\n\t\ta := abi.GetABI(instance, AbiV2)\n\t\ta.SetABIImports(f)\n\t\texports := a.GetABIExports().(Exports)\n\t\tf.LayottoHandler.Instance = instance\n\n\t\tinstance.Lock(a)\n\t\tdefer instance.Unlock()\n\n\t\t// \u4f7f\u7528 exports \u51fd\u6570 proxy_get_id\uff08\u5bf9\u5e94\u5230 WASM \u63d2\u4ef6\u4e2d GetID \u51fd\u6570\uff09\u83b7\u53d6 WASM \u7684 ID\n\t\tid, err := exports.ProxyGetID()\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] createProxyWasmFilterFactory fail to get wasm id, PluginName: %s, err: %v",\n\t\t\t\tplugin.PluginName(), err)\n\t\t\treturn true\n\t\t}\n\t\t// \u628aID \u548c \u5bf9\u5e94\u7684\u63d2\u4ef6\u6ce8\u518c\u5230\u8def\u7531\u4e2d\uff0c\u5373\u53ef\u901a\u8fc7 http Header \u4e2d\u7684\u952e\u503c\u5bf9\u8fdb\u884c\u8def\u7531\uff0c\u6bd4\u5982 \'id:id_1\' \u5c31\u4f1a\u6839\u636e id_1 \u8def\u7531\u5230\u4e0a\u9762\u7684 Function1 \n\t\tf.router.RegisterRoute(id, wasmPlugin)\n\n\t\t// \u5f53\u7b2c\u4e00\u4e2a\u63d2\u4ef6\u4f7f\u7528\u7ed9\u5b9a\u7684\u6839 ID \u52a0\u8f7d\u65f6\u901a\u8fc7 proxy_on_context_create \u521b\u5efa\u6839\u4e0a\u4e0b\u6587\uff0c\u5e76\u5728\u865a\u62df\u673a\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d\u6301\u7eed\u5b58\u5728\uff0c\u76f4\u5230 proxy_on_delete \u5220\u9664 \n\t\t// \u503c\u5f97\u6ce8\u610f\u7684\u662f\u8fd9\u91cc\u8bf4\u7684\u7b2c\u4e00\u4e2a\u63d2\u4ef6\u6307\u7684\u662f\u591a\u4e2a\u677e\u6563\u7ed1\u5b9a\u7684\u63d2\u4ef6(\u901a\u8fc7 SDK \u4f7f\u7528 Root ID \u5bf9 Root Context \u8bbf\u95ee\uff09\u5728\u540c\u4e00\u5df2\u914d\u7f6e\u865a\u62df\u673a\u5185\u5171\u4eab\u6570\u636e\u7684\u4f7f\u7528\u573a\u666f [4]\n\t\terr = exports.ProxyOnContextCreate(f.RootContextID, 0)\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\tvmConfigSize := 0\n\t\tif vmConfigBytes := wasmPlugin.GetVmConfig(); vmConfigBytes != nil {\n\t\t\tvmConfigSize = vmConfigBytes.Len()\n\t\t}\n\n\t\t// VM \u4f34\u968f\u542f\u52a8\u7684\u63d2\u4ef6\u542f\u52a8\u65f6\u8c03\u7528\n\t\t_, err = exports.ProxyOnVmStart(f.RootContextID, int32(vmConfigSize))\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\tpluginConfigSize := 0\n\t\tif pluginConfigBytes := wasmPlugin.GetPluginConfig(); pluginConfigBytes != nil {\n\t\t\tpluginConfigSize = pluginConfigBytes.Len()\n\t\t}\n\n\t\t// \u5f53\u63d2\u4ef6\u52a0\u8f7d\u6216\u91cd\u65b0\u52a0\u8f7d\u5176\u914d\u7f6e\u65f6\u8c03\u7528\n\t\t_, err = exports.ProxyOnConfigure(f.RootContextID, int32(pluginConfigSize))\n\t\tif err != nil {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][factory] OnPluginStart fail to create root context id, err: %v", err)\n\t\t\treturn true\n\t\t}\n\n\t\treturn true\n\t})\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"workflow",children:"Workflow"}),"\n",(0,r.jsxs)(e.p,{children:["The workflow for Layotto Middle WASM is broadly as shown in figure 2 Layotto & Mosn WASM workflow, where the configuration is largely covered by the initial elements above, with a focus on the request processing.\n",(0,r.jsx)(e.img,{src:"https://gw.alipaayobjects.com/md/rms_5891a1/afts/img/A*XTDeRq0alYsAAAAAAAAAAAAAAAAAAAAARQAQAQ",alt:"mosn_wasm_ext_framework_workflow"})]}),"\n",(0,r.jsx)("center",{children:"Figure 2 Layotto & Mosn WAS Workflow "}),"\n",(0,r.jsx)(e.p,{children:"1\u3001\u7531 Layotto \u5e95\u5c42 Mosn \u6536\u5230\u8bf7\u6c42\uff0c\u7ecf\u8fc7 workpool \u8c03\u5ea6\uff0c\u5728 proxy downstream \u4e2d\u6309\u7167\u914d\u7f6e\u4f9d\u6b21\u6267\u884c StreamFilterChain \u5230 Wasm StreamFilter \u7684 OnReceive \u65b9\u6cd5\uff0c\u5177\u4f53\u903b\u8f91\u8be6\u89c1\u5982\u4e0b\u4ee3\u7801\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func (f *Filter) OnReceive(ctx context.Context, headers api.HeaderMap, buf buffer.IoBuffer, trailers api.HeaderMap) api.StreamFilterStatus {\n\t// \u83b7\u53d6 WASM \u63d2\u4ef6\u7684 id\n\tid, ok := headers.Get("id")\n\tif !ok {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders no id in headers")\n\t\treturn api.StreamFilterStop\n\t}\n    \n\t// \u4ece router \u4e2d\u6839\u636e id \u83b7\u53d6\u5bf9\u5e94\u7684 WASM \u63d2\u4ef6\n\twasmPlugin, err := f.router.GetRandomPluginByID(id)\n\tif err != nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders id, err: %v", err)\n\t\treturn api.StreamFilterStop\n\t}\n\tf.pluginUsed = wasmPlugin\n\n\tplugin := wasmPlugin.plugin\n\t// \u83b7\u53d6 WasmInstance \u5b9e\u4f8b\n\tinstance := plugin.GetInstance()\n\tf.instance = instance\n\tf.LayottoHandler.Instance = instance\n\n\t// ABI \u5305\u542b \u5bfc\u51fa(Exports)\u548c\u5bfc\u5165(Imports)\u4e24\u4e2a\u90e8\u5206\uff0c\u7528\u6237\u901a\u8fc7\u8fd9\u5b83\u4eec\u4e0e WASM \u6269\u5c55\u63d2\u4ef6\u8fdb\u884c\u4ea4\u4e92\n\tpluginABI := abi.GetABI(instance, AbiV2)\n\tif pluginABI == nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive fail to get instance abi")\n\t\tplugin.ReleaseInstance(instance)\n\t\treturn api.StreamFilterStop\n\t}\n\t// \u8bbe\u7f6e\u5bfc\u5165 Imports \u90e8\u5206\uff0c\u5bfc\u5165\u90e8\u5206\u7531\u7528\u6237\u63d0\u4f9b\uff0c\u865a\u62df\u673a\u7684\u6267\u884c\u9700\u8981\u4f9d\u8d56\u5bbf\u4e3b\u673a Layotto \u63d0\u4f9b\u7684\u90e8\u5206\u80fd\u529b\uff0c\u4f8b\u5982\u83b7\u53d6\u8bf7\u6c42\u4fe1\u606f\uff0c\u8fd9\u4e9b\u80fd\u529b\u901a\u8fc7\u5bfc\u5165\u90e8\u5206\u7531\u7528\u6237\u63d0\u4f9b\uff0c\u5e76\u7531 WASM \u6269\u5c55\u8c03\u7528\n\tpluginABI.SetABIImports(f)\n\n\t// \u5bfc\u51fa Exports \u90e8\u5206\u7531 WASM \u63d2\u4ef6\u63d0\u4f9b\uff0c\u7528\u6237\u53ef\u76f4\u63a5\u8c03\u7528\u2014\u2014\u5524\u9192 WASM \u865a\u62df\u673a\uff0c\u5e76\u5728\u865a\u62df\u673a\u4e2d\u6267\u884c\u5bf9\u5e94\u7684 WASM \u63d2\u4ef6\u4ee3\u7801\n\texports := pluginABI.GetABIExports().(Exports)\n\tf.exports = exports\n\t\n\tinstance.Lock(pluginABI)\n\tdefer instance.Unlock()\n\t\n\t// \u6839\u636e rootContextID \u548c contextID \u521b\u5efa\u5f53\u524d\u63d2\u4ef6\u4e0a\u4e0b\u6587\n\terr = exports.ProxyOnContextCreate(f.contextID, wasmPlugin.rootContextID)\n\tif err != nil {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] NewFilter fail to create context id: %v, rootContextID: %v, err: %v",\n\t\t\tf.contextID, wasmPlugin.rootContextID, err)\n\t\treturn api.StreamFilterStop\n\t}\n\n\tendOfStream := 1\n\tif (buf != nil && buf.Len() > 0) || trailers != nil {\n\t\tendOfStream = 0\n\t}\n\n\t// \u8c03\u7528 proxy-wasm-go-host\uff0c\u7f16\u7801\u8bf7\u6c42\u5934\u4e3a\u89c4\u8303\u6307\u5b9a\u7684\u683c\u5f0f\n\taction, err := exports.ProxyOnRequestHeaders(f.contextID, int32(headerMapSize(headers)), int32(endOfStream))\n\tif err != nil || action != proxywasm.ActionContinue {\n\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestHeaders err: %v", err)\n\t\treturn api.StreamFilterStop\n\t}\n\n\tendOfStream = 1\n\tif trailers != nil {\n\t\tendOfStream = 0\n\t}\n\n\tif buf == nil {\n\t\targ, _ := variable.GetString(ctx, types.VarHttpRequestArg)\n\t\tf.requestBuffer = buffer.NewIoBufferString(arg)\n\t} else {\n\t\tf.requestBuffer = buf\n\t}\n\n\tif f.requestBuffer != nil && f.requestBuffer.Len() > 0 {\n\t\t// \u8c03\u7528 proxy-wasm-go-host\uff0c\u7f16\u7801\u8bf7\u6c42\u4f53\u4e3a\u89c4\u8303\u6307\u5b9a\u7684\u683c\u5f0f\n\t\taction, err = exports.ProxyOnRequestBody(f.contextID, int32(f.requestBuffer.Len()), int32(endOfStream))\n\t\tif err != nil || action != proxywasm.ActionContinue {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestBody err: %v", err)\n\t\t\treturn api.StreamFilterStop\n\t\t}\n\t}\n\n\tif trailers != nil {\n        // \u8c03\u7528 proxy-wasm-go-host\uff0c\u7f16\u7801\u8bf7\u6c42\u5c3e\u4e3a\u89c4\u8303\u6307\u5b9a\u7684\u683c\u5f0f\n\t\taction, err = exports.ProxyOnRequestTrailers(f.contextID, int32(headerMapSize(trailers)))\n\t\tif err != nil || action != proxywasm.ActionContinue {\n\t\t\tlog.DefaultLogger.Errorf("[proxywasm][filter] OnReceive call ProxyOnRequestTrailers err: %v", err)\n\t\t\treturn api.StreamFilterStop\n\t\t}\n\t}\n\n\treturn api.StreamFilterContinue\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"2, proxy-wasm-go-host encode Mosn requests for triplets into the specified format and call Proxy-Wasm ABI equivalent interface in Proxy_on_request_headers and call the WASMER virtual machine to pass the request information to the WASM plugin."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func (a *ABIContext) CallWasmFunction (functionName string, args ..interface{}) (interface{}, Action, error) um\n\tff, err := a.Instance. eExportsFunc(functionName)\n\tif err != nil {\n\t\treturn nil, ActionContinue, err\n\t}\n\n\t// Call waste virtual machine (Github.com/wasmerio/wasmer-go/wasmer.(*Function).Call at function.go)\n\tres, err := ff. all(args....)\n\tif err != nil L/\n\t\ta.Instance.HandleError(err)\n\t\treturn nil, ActionContinue, err\n\t}\n\n\t// if we have sync call, e. HttpCall, then unlocked the waste instance and wait until it resp\n\taction := a.Imports.Wait()\n\n\treturn res, action, nil\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["3\u3001WASMER \u865a\u62df\u673a\u7ecf\u8fc7\u5904\u7406\u8c03\u7528 WASM \u63d2\u4ef6\u7684\u5177\u4f53\u51fd\u6570\uff0c\u6bd4\u5982\u4f8b\u5b50\u4e2d\u7684 OnHttpRequestBody \u51fd\u6570\n// function, ",(0,r.jsx)(e.em,{children:':= instance.Exports.GetFunction("exported_function")\n// nativeFunction = function.Native()\n//'})," = nativeFunction(1, 2, 3)\n// Native \u4f1a\u5c06 Function \u8f6c\u6362\u4e3a\u53ef\u4ee5\u8c03\u7528\u7684\u539f\u751f Go \u51fd\u6570"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func (self *Function) Native() NativeFunction {\n\t...\n\tself.lazyNative = func(receivedParameters ...interface{}) (interface{}, error) {\n\t\tnumberOfReceivedParameters := len(receivedParameters)\n\t\tnumberOfExpectedParameters := len(expectedParameters)\n\t\t...\n\t\tresults := C.wasm_val_vec_t{}\n\t\tC.wasm_val_vec_new_uninitialized(&results, C.size_t(len(ty.Results())))\n\t\tdefer C.wasm_val_vec_delete(&results)\n\n\t\targuments := C.wasm_val_vec_t{}\n\t\tdefer C.wasm_val_vec_delete(&arguments)\n\n\t\tif numberOfReceivedParameters > 0 {\n\t\t\tC.wasm_val_vec_new(&arguments, C.size_t(numberOfReceivedParameters), (*C.wasm_val_t)(unsafe.Pointer(&allArguments[0])))\n\t\t}\n\n\t\t// \u8c03\u7528 WASM \u63d2\u4ef6\u5185\u51fd\u6570\n\t\ttrap := C.wasm_func_call(self.inner(), &arguments, &results)\n\n\t\truntime.KeepAlive(arguments)\n\t\truntime.KeepAlive(results)\n\t\t...\n\t}\n\n\treturn self.lazyNative\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"4, proxy-wasm-go-sdk converts the requested data from the normative format to a user-friendly format and then calls the user extension code.Proxy-wasm-go-sdk, based on proxy-waste/spec implementation, defines the interface between function access to system resources and infrastructure services, and builds on this integration of the Runtime API, adding ABI to infrastructure access."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'// function1\u4e3b\u8981\u903b\u8f91\u5c31\u662f\u63a5\u6536 HTTP \u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7 ABI \u8c03\u7528 function2\uff0c\u5e76\u8fd4\u56de function2 \u7ed3\u679c\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u4e0b\u6240\u793a\nfunc (ctx *httpHeaders) OnHttpRequestBody(bodySize int, endOfStream bool) types.Action {\n\t//1. get request body\n\tbody, err := proxywasm.GetHttpRequestBody(0, bodySize)\n\tif err != nil {\n\t\tproxywasm.LogErrorf("GetHttpRequestBody failed: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//2. parse request param\n\tbookName, err := getQueryParam(string(body), "name")\n\tif err != nil {\n\t\tproxywasm.LogErrorf("param not found: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//3. request function2 through ABI\n\tinventories, err := proxywasm.InvokeService("id_2", "", bookName)\n\tif err != nil {\n\t\tproxywasm.LogErrorf("invoke service failed: %v", err)\n\t\treturn types.ActionPause\n\t}\n\n\t//4. return result\n\tproxywasm.AppendHttpResponseBody([]byte("There are " + inventories + " inventories for " + bookName + "."))\n\treturn types.ActionContinue\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"5, WASM plugin is registered at RegisterFunc initialization. For example, Function1 RPC calls Proxy InvokeService,Function2 to get ProxyGetState specified in Redis as shown below in\uff1a"}),"\n",(0,r.jsx)(e.p,{children:"Function1 Call Function2, Proxy InvokeService for Imports function proxy_invoke_service through the Proxy InvokeService"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func ProxyInvokeService(instance common). asmInstance, idPtr int32, idSize int32, methodPtr int32, methodPtr int32, paramPtr int32, resultPtr int32, resultSize int32) int32 56\n\tid, err := instance. etMemory(uint64(idPtr), uint64(idSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAcces.Int32()\n\t}\n\n\tmethod, err := instance. etMemory(uint64 (methodPtr), uint64 (methodSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess. nt32()\n\t}\n\n\tparam, err := instance.GetMemory(uint64 (paramPtr), uint64 (paramSize))\n\tif err != nil Fe\n\t\treturnn WasmResultInvalidMemoryAccess. nt32()\n\t}\n\n\tctx:= getImportHandler(instance)\n    \n\t// Laytto rpc calls\n\tret, res := ctx. nvokeService(string(id), string(param))\n\tif res != WasmResultOk 6\n\t\treturn res.Int32()\n\n\n\treturn copyIntoInstance(instance, ret, resultPtr, resultSize).Int32()\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"Function2 Get Redis via ProxyGetState to specify key Valye, ProxyGetState for Imports function proxy_get_state"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func ProxyGetState(instance common.WasmInstance, storeNamePtr int32, storeNameSize int32, keyPtr int32, valuePtr int32, valueSize int32) int32 Fe\n\tstoreName, err := instance. etMemory(uint64 (storeNamePtr), uint64 (storeNameSize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess.Int32()\n\t}\n\n\tkey, err := instance. etMemory(uint64(keyPtr), uint64(keySize))\n\tif err != nil LO\n\t\treturnWasmResultInvalidMemoryAccess.Int32()\n\t}\n\n\tctx := getImportHandler(instance)\n\n\tret, res := ctx. etState(string(storeName), string(key))\n\tif res != WasmResultOk 6\n\t\treturn res.Int32()\n\t}\n\n\treturn copyIntoInstance(instance, ret, valuePtr, valueSize). Int32()\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["More than the Layotto rpc process is briefly described as the implementation of [5]by two virtual connections using the Dapr API and underneath Mosn, see previous order articles [Layotto source parsing \u2014 processing RPC requests] (",(0,r.jsx)(e.a,{href:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index",children:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index"}),"), where data from Redis can be obtained directly from Dapr State code and is not developed here."]}),"\n",(0,r.jsx)(e.h3,{id:"faas-mode",children:"FaaS Mode"}),"\n",(0,r.jsx)(e.p,{children:"Look back back to the WASM features\uff1abytes code that match the machine code; guarantee good segregation and security in the sandbox; compile cross-platforms, easily distributed, and load running; have lightweight and multilingual flexibilities and seem naturally suitable for FaaS."}),"\n",(0,r.jsx)(e.p,{children:"So Layotto also explores support for WASM FaaS mode by loading and running WASM carrier functions and supporting interfaces and access to infrastructure between Function.Since the core logic of loading the WASM has not changed, except that there is a difference between usage and deployment methods and those described above, the Layotto load part of the ASM logic is not redundant."}),"\n",(0,r.jsx)(e.p,{children:'In addition to the Wasm-Proxy implementation, the core logic of the FaaS mode is to manage the *.wasm package and Kubernetes excellent structuring capabilities by expanding Containerd to multiple-run plugins containerd-shim-layotto-v2 [6]and using this "piercing wire" ingenuity to use Docker mirror capability. Specific structures and workflows can be found in Figure 3 Layotto FaaS Workflow.'}),"\n",(0,r.jsxs)(e.p,{children:["![layotto_faas_workflow](",(0,r.jsx)(e.a,{href:"https://gw.alipaayobjects.com/md/rms_5891a1/afts/img/A%5C*XWmNT6-7",children:"https://gw.alipaayobjects.com/md/rms_5891a1/afts/img/A\\*XWmNT6-7"})," FoEAAAAAAAAAAAAAAAAAAAAAARQAQAQ)"]}),"\n",(0,r.jsx)("center",{children:"Figure 3 Layotto FaaS Workflow "}),"\n",(0,r.jsx)(e.p,{children:"Here a simple look at the master function of containerd-shim-layotto-v2. It can be seen that shim.Run runs the WASM as io.containerd.layotto.v2, and runtime_type of the containerd plugins.crimerd.runtimes corresponding to the plugin.When creating a Pod, you specify runtimeClassName: layotto in yaml speed, and eventually kubelet will load and run them when cric-plugin calls containerd-shim-layotto-v2 is running."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func main() {\n\tstartLayotto()\n\t// \u89e3\u6790\u8f93\u5165\u53c2\u6570\uff0c\u521d\u59cb\u5316\u8fd0\u884c\u65f6\u73af\u5883\uff0c\u8c03\u7528 wasm.New \u5b9e\u4f8b\u5316 service \u5bf9\u8c61 \n\tshim.Run("io.containerd.layotto.v2", wasm.New)\n}\n\nfunc startLayotto() {\n\tconn, err := net.Dial("tcp", "localhost:2045")\n\tif err == nil {\n\t\tconn.Close()\n\t\treturn\n\t}\n\n\tcmd := exec.Command("layotto", "start", "-c", "/home/docker/config.json")\n\tcmd.Start()\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(e.p,{children:['Layotto WebAssemly involves more basic WASM knowledge, but it is understandable that the examples are shallow deeper and gradual.At the end of the spectrum, the ASM technology can be seen to have been applied to many fields such as Web-Front, Serverlessness, Game Scene, Edge Computing, Service Grids, or even to the Docker parent Solomon Hykes recently said: "If the WASM technology is available in 2008, I will not be able to do the Docker" (later added that\uff1aDocker will not be replaced and will walk side by side with WASM) The ASM seems to be becoming lighter and better performing cloud-origin technology and being applied to more areas after the VM and Container, while believing that there will be more use scenes and users in Mosn community push and in Layotto continue exploration, here Layotto WebAssemly relevant source code analysis has been completed. Given time and length, some more comprehensive and in-depth profiles have not been carried out, and if there are flaws, welcome fingers, contact\uff1arayo. ',(0,r.jsx)(e.a,{href:"mailto:angzl@gmail.com",children:"angzl@gmail.com"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"references",children:"References"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["[1] ",(0,r.jsx)(e.a,{href:"https://mosn.io/blog/posts/mosn-waste-framework/",children:"WebAssembly practice in MOSN"})]}),"\n",(0,r.jsxs)(e.li,{children:["[2] ",(0,r.jsx)(e.a,{href:"https://github.com/mosn/mosn/pull/1589",children:"feature: WASM plugin framework"})]}),"\n",(0,r.jsxs)(e.li,{children:["[3] ",(0,r.jsx)(e.a,{href:"https://github.com/proxy-wasm/spec",children:"WebAssembly for Proxies (ABI Spec)"})]}),"\n",(0,r.jsxs)(e.li,{children:["[4] ",(0,r.jsx)(e.a,{href:"https://techhenzy.com/proxy-webassembly-archive/",children:"Proxy WebAssembly Architecture"})]}),"\n",(0,r.jsxs)(e.li,{children:["[5] ",(0,r.jsx)(e.a,{href:"https://mosn.io/layotto/#/blog/code/layotto-rpc/index",children:"Layotto source parse \u2014 processing RPC requests"})]}),"\n",(0,r.jsxs)(e.li,{children:["[6] ",(0,r.jsx)(e.a,{href:"https://www.soft.tech/blog/the-next-fuve-years-of-cloud-native-runtime/",children:"\u4e91\u539f\u751f\u8fd0\u884c\u65f6\u7684\u4e0b\u4e00\u4e2a\u4e94\u5e74"})]}),"\n"]})]})}function m(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(u,{...t})}):u(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>s});var r=n(6540);const o={},i=r.createContext(o);function a(t){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:a(t.components),r.createElement(i.Provider,{value:e},t.children)}}}]);