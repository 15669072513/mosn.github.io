<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MOSN – 架构原理</title>
    <link>https://mosn.io/zh/docs/concept/</link>
    <description>Recent content in 架构原理 on MOSN</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 04 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="https://mosn.io/zh/docs/concept/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: MOSN 多协议机制解析</title>
      <link>https://mosn.io/zh/docs/concept/multi-protocol/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mosn.io/zh/docs/concept/multi-protocol/</guid>
      <description>
        
        
        

&lt;p&gt;我们将按以下顺序进行介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多协议机制产生的背景与实践痛点；&lt;/li&gt;
&lt;li&gt;常见的协议扩展思路初探；&lt;/li&gt;
&lt;li&gt;SOFABolt 协议接入实践；&lt;/li&gt;
&lt;li&gt;MOSN 多协议机制设计解读；&lt;/li&gt;
&lt;li&gt;后续规划及展望；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中第三点「接入实践」是今天分享的重点，希望能给大家就「如何在 MOSN 中快速扩展私有协议接入」有一个具体的感受。另外「MOSN 如何实现多协议框架」也是很多人关心和问题，我们将摘选几个技术功能，对其背后的设计思考进行解读。&lt;/p&gt;

&lt;h2 id=&#34;多协议机制产生的背景与实践痛点&#34;&gt;多协议机制产生的背景与实践痛点&lt;/h2&gt;

&lt;p&gt;首先介绍一下多协议机制产生的背景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248463-b8b38ab0-09ed-4225-8d60-5bad3c2a372b.png&#34; alt=&#34;多协议机制&#34; /&gt;&lt;/p&gt;

&lt;p&gt;前面提到，蚂蚁金服 2019 年双十一核心链路百分之百 Mesh 化，是业界当时已知的最大规模的 Service Mesh 落地，为什么我们敢这么做？因为我们具备能够让架构平滑迁移的方案。&amp;rdquo;兼容性&amp;rdquo;是任何架构演进升级都必然要面对的一个问题，这在早已实践微服务化架构的蚂蚁金服内部同样如此。为了实现架构的平滑迁移，需要让新老节点的外在行为尽可能的表现一致，从而让依赖方无感知，这其中很重要的一点就是保持协议兼容性。&lt;/p&gt;

&lt;p&gt;因此，我们需要在 Service Mesh 架构下，兼容现有微服务体系中的通信协议——也就是说需要在 MOSN 内实现对目前蚂蚁金服内部通信协议的扩展支持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248513-3bf90371-3d7c-4a0f-a98a-db4538bb2271.png&#34; alt=&#34;协议扩展支持&#34; /&gt;&lt;/p&gt;

&lt;p&gt;基于 MOSN 本身的扩展机制，我们完成了最初版本的协议扩展接入。但是在实践过程中，我们发现这并不是一件容易的事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;相比编解码，协议自身的处理以及与框架集成才是其中最困难的环节，需要理解并实现包括请求生命周期、多路复用处理、链接池等等机制；&lt;/li&gt;
&lt;li&gt;社区主流的 xDS 路由配置是面向 HTTP 协议的，无法直接支持私有协议，存在适配成本；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于这些实践痛点，我们设计了 MOSN 多协议框架，希望可以降低私有协议的接入成本，加快普及 ServiceMesh 架构的落地推进。&lt;/p&gt;

&lt;h2 id=&#34;常见的协议扩展思路初探&#34;&gt;常见的协议扩展思路初探&lt;/h2&gt;

&lt;p&gt;前面介绍了背景，那么具体协议扩展框架要怎么设计呢？我们先来看一下业界的思路与做法。&lt;/p&gt;

&lt;h3 id=&#34;协议扩展框架-envoy&#34;&gt;协议扩展框架 - Envoy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248576-01797bba-8a94-4960-be17-1c87c725a75a.png&#34; alt=&#34;Envoy 的协议扩展&#34; /&gt;
注：图片来自 Envoy 分享资料&lt;/p&gt;

&lt;p&gt;第一个要介绍的是目前发展势头强劲的 Envoy。从图上可以看出，Envoy 支持四层的读写过滤器扩展、基于 HTTP 的七层读写过滤器扩展以及对应的 Router/Upstream 实现。如果想要基于 Envoy 的扩展框架实现 L7 协议接入，目前的普遍做法是基于 L4 filter 封装相应的 L7 codec，在此基础之上再实现对应的协议路由等能力，无法复用 HTTP L7 的扩展框架。&lt;/p&gt;

&lt;h3 id=&#34;协议扩展框架-nginx&#34;&gt;协议扩展框架 - Nginx&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248600-c47725ed-7d47-4c07-ad1b-f2e2ba4ea2c6.png&#34; alt=&#34;Nginx 的协议扩展&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二个则是老牌的反向代理软件 Nginx，其核心模块是基于 Epoll/Kqueue 等 I/O 多路复用技术之上的离散事件框架，基于事件框架之上构建了 Mail、Http 等协议模块。与 Envoy 类似，如果要基于 Nginx 扩展私有协议，那么也需要自行对接事件框架，并完整实现包括编解码、协议处理等能力。&lt;/p&gt;

&lt;h3 id=&#34;协议扩展框架-mosn&#34;&gt;协议扩展框架 - MOSN&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248645-5d6eac2f-962e-4c3c-92f1-814d18db47cd.png&#34; alt=&#34;MOSN 的协议扩展框架&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后回过头来，我们看一下 MOSN 是怎么做的。实际上，MOSN 的底层机制与 Envoy、Nginx 并没有核心差异，同样支持基于 I/O 多路复用的 L4 读写过滤器扩展，并在此基础之上再封装 L7 的处理。但是与前两者不同的是，MOSN 针对典型的微服务通信场景，抽象出了一套适用于基于多路复用 RPC 协议的扩展框架，屏蔽了 MOSN 内部复杂的协议处理及框架流程，开发者只需要关注协议本身，并实现对应的框架接口能力即可实现快速接入扩展。&lt;/p&gt;

&lt;h3 id=&#34;三种框架成本对比&#34;&gt;三种框架成本对比&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248614-5807d3b3-fb18-4a15-83ef-e05bb162f222.png&#34; alt=&#34;三种框架成本对比&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后对比一下，典型微服务通信框架协议接入的成本，由于 MOSN 针对此类场景进行了框架层面的封装支持，因此可以节省开发者大量的研发成本。&lt;/p&gt;

&lt;h2 id=&#34;sofabolt-协议接入实践&#34;&gt;SOFABolt 协议接入实践&lt;/h2&gt;

&lt;p&gt;初步了解多协议框架的设计思路之后，让我们以 SOFABolt 协议为例来实际体验一下协议接入的过程。&lt;/p&gt;

&lt;h3 id=&#34;sofabolt-简介&#34;&gt;SOFABolt 简介&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248663-0e25c95b-d711-4de2-9a42-f71d05b360df.png&#34; alt=&#34;SOFABolt 简介&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里先对 SOFABolt 进行一个简单介绍，SOFABolt 是一个开源的轻量、易用、高性能、易扩展的  RPC 通信框架，广泛应用于蚂蚁金服内部。&lt;/p&gt;

&lt;p&gt;SOFABolt：&lt;a href=&#34;https://github.com/sofastack/sofa-bolt&#34; target=&#34;_blank&#34;&gt;https://github.com/sofastack/sofa-bolt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基于 MOSN 的多协议框架，实际编写了 7 个代码文件，一共 925 行代码(包括 liscence、comment 在内)就完成了接入。如果对于协议本身较为熟悉，且具备一定的 MOSN/Golang 开发经验，甚至可以在一天内就完成整个协议的扩展，可以说接入成本是非常之低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248669-1138c7d3-fc69-446c-99a9-65932aebca99.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Github:
&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/pkg/protocol/xprotocol/bolt&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/pkg/protocol/xprotocol/bolt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面让我们进入正题，一步一步了解接入过程。&lt;/p&gt;

&lt;h3 id=&#34;step1-确认协议格式&#34;&gt;Step1：确认协议格式&lt;/h3&gt;

&lt;p&gt;第一步，需要确认要接入的协议格式。为什么首先要做这个，因为协议格式是一个协议最基本的部分，有以下两个层面的考虑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任何协议特性以及协议功能都能在上面得到一些体现，例如有无 requestId/streamId 就直接关联到协议是否支持连接多路复用；&lt;/li&gt;
&lt;li&gt;协议格式与报文模型直接相关，两者可以构成逻辑上的映射关系；而这个映射关系也就是所谓的编解码逻辑；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;1585209248674-536ba7de-4f23-4797-a3db-cc085ec8a620.png&#34; alt=&#34;确认协议格式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以 SOFABolt 为例，其第一个字节是协议 magic，可以用于校验当前报文是否属于 SOFABolt 协议，并可以用于协议自动识别匹配的场景；第二个字节是 type，用于标识当前报文的传输类型，可以是 Request / RequestOneway / Response 中的一种；第三个字节则是当前报文的业务类型，可以是心跳帧，RPC 请求/响应等类型。后面的字段就不一一介绍了，可以发现，&lt;strong&gt;理解了协议格式本身，其实对于协议的特性支持和模型编解码就理解了一大半，&lt;/strong&gt;因此第一步协议格式的确认了解是重中之重，是后续一切工作开展的前提。&lt;/p&gt;

&lt;h3 id=&#34;step2-确认报文模型&#34;&gt;Step2：确认报文模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248773-66c3234b-f805-4735-9e70-acf8abef294b.png&#34; alt=&#34;确认报文模型&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺应第一步，第二步的主要工作是确认报文编程模型。一般地，在第一步完成之后，应当可以很顺利的构建出相应的报文模型，SOFABolt 例子中可以看出，模型字段设计基本与协议格式中的 header / payload 两部分相对应。有了编程模型之后，就可以继续进行下一步——基于模型实现对应的框架扩展了。&lt;/p&gt;

&lt;h3 id=&#34;step3-接口实现-协议&#34;&gt;Step3：接口实现 - 协议&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248724-28eaa458-a928-4f19-bf16-96895808a5b8.png&#34; alt=&#34;接口实现-协议&#34; /&gt;&lt;/p&gt;

&lt;p&gt;协议扩展，顾名思义，是指协议层面的扩展，描述的是协议自身的行为（区别于报文自身）。&lt;/p&gt;

&lt;p&gt;目前多协议框架提供的接口包括以下五个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Name：协议名称，需要具备唯一性；&lt;/li&gt;
&lt;li&gt;Encoder：编码器，用于实现从报文模型到协议传输字节流的映射转换；&lt;/li&gt;
&lt;li&gt;Decoder：解码器，用于实现从协议传输字节流到报文模型的映射转换；&lt;/li&gt;
&lt;li&gt;Heartbeater：心跳处理，用于实现心跳保活报文的构造，包括探测发起与回复两个场景；&lt;/li&gt;
&lt;li&gt;Hijacker：错误劫持，用于在特定错误场景下错误报文的构造；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step4-接口实现-报文&#34;&gt;Step4：接口实现 - 报文&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248793-9cb8efd3-c12e-4da1-91f9-0901bcf36e16.png&#34; alt=&#34;接口实现-报文&#34; /&gt;&lt;/p&gt;

&lt;p&gt;前面介绍了协议扩展，接下里则是报文扩展，这里关注的是单个请求报文需要实现的行为。&lt;/p&gt;

&lt;p&gt;目前框架抽象的接口包括以下几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Basic：需要提供 GetStreamType、GetHeader、GetBody 几个基础方法，分别对应传输类型、头部信息、载荷信息；&lt;/li&gt;
&lt;li&gt;Multiplexing：多路复用能力，需要实现 GetRequestId 及 SetRequestId；&lt;/li&gt;
&lt;li&gt;HeartbeatPredicate：用于判断当前报文是否为心跳帧；&lt;/li&gt;
&lt;li&gt;GoAwayPredicate：用于判断当前报文是否为优雅退出帧；&lt;/li&gt;
&lt;li&gt;ServiceAware：用于从报文中获取 service、method 等服务信息；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举个例子&#34;&gt;举个例子&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248756-4c3fce60-436b-4153-9372-b39fe80fc975.png&#34; alt=&#34;案例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里举一个例子，来让大家对&lt;strong&gt;框架如何基于接口封装处理流程&lt;/strong&gt;有一个体感：服务端心跳处理场景。当框架收到一个报文之后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据报文扩展中的 GetStreamType 来确定当前报文是请求还是响应。如果是请求则继续 2；&lt;/li&gt;
&lt;li&gt;根据报文扩展中的 HeartbeatPredicate 来判断当前报文是否为心跳包，如果是则继续 3；&lt;/li&gt;
&lt;li&gt;当前报文是心跳探测(request + heartbeat)，需要回复心跳响应，此时根据协议扩展中的 Heartbeater.Reply 方法构造对应的心跳响应报文；&lt;/li&gt;
&lt;li&gt;再根据协议扩展的 Encoder 实现，将心跳响应报文转换为传输字节流；&lt;/li&gt;
&lt;li&gt;最后调用 MOSN 网络层接口，将传输字节流回复给发起心跳探测的客户端；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当协议扩展与报文扩展都实现之后，MOSN 协议扩展接入也就完成了，框架可以依据协议扩展的实现来完成协议的处理，让我们实际演示一下 SOFABolt 接入的 example。&lt;/p&gt;

&lt;p&gt;Demo 地址：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/sofarpc-with-xprotocol-sample&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/sofarpc-with-xprotocol-sample&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mosn-多协议机制设计解读&#34;&gt;MOSN 多协议机制设计解读&lt;/h2&gt;

&lt;p&gt;通过 SOFABolt 协议接入的实践过程，大家对如何基于 MOSN 来做协议扩展应该有了一个初步的认知。那么 MOSN 多协议机制究竟封装了哪些逻辑，背后又是如何思考设计的？接下来将会挑选几个典型技术案例为大家进行解读。&lt;/p&gt;

&lt;h3 id=&#34;协议扩展框架&#34;&gt;协议扩展框架&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;协议扩展框架 -  编解码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585227625966-1b00d83d-fff1-40f1-b6b1-3bda19db0afb.png&#34; alt=&#34;协议扩展框架-编解码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最先介绍的是编解码机制，这个在前面 SOFABolt 接入实践中已经简单介绍过，MOSN 定义了编码器及解码器接口来屏蔽不同协议的编解码细节。协议接入时只需要实现编解码接口，而不用关心相应的接口调用上下文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协议扩展框架 - 多路复用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248762-c83706cd-b413-468c-80b1-151de9ae8f3c.png&#34; alt=&#34;协议扩展看框架-多路复用&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来是多路复用机制的解读，这也是流程中相对不太好理解的一部分。首先明确一下链接多路复用的定义：允许在单条链接上，并发处理多个请求/响应。那么支持多路复用有什么好处呢？&lt;/p&gt;

&lt;p&gt;以 HTTP 协议演进为例，HTTP/1 虽然可以维持长连接，但是单条链接同一时间只能处理一个请求/相应，这意味着如果同时收到了 4 个请求，那么需要建立四条 TCP 链接，而建链的成本相对来说比较高昂；HTTP/2 引入了 stream/frame 的概念，支持了分帧多路复用能力，在逻辑上可以区分出成对的请求 stream 和响应 stream，从而可以在单条链接上并发处理多个请求/响应，解决了 HTTP/1 链接数与并发数成正比的问题。&lt;/p&gt;

&lt;p&gt;类似的，典型的微服务框架通信协议，如 Dubbo、SOFABolt 等一般也都实现了链接多路复用能力，因此 MOSN 封装了相应的多路复用处理流程，来简化协议接入的成本。让我们跟随一个请求代理的过程，来进一步了解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248791-900751cb-c096-48d4-a5d5-d8247ef9d725.png&#34; alt=&#34;上下游关联映射&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MOSN 从 downstream(conn=2) 接收了一个请求 request，依据报文扩展多路复用接口 GetRequestId 获取到请求在这条连接上的身份标识(requestId=1)，并记录到关联映射中待用；&lt;/li&gt;
&lt;li&gt;请求经过 MOSN 的路由、负载均衡处理，选择了一个 upstream(conn=5)，同时在这条链接上新建了一个请求流(requestId=30)，并调用文扩展多路复用接口 SetRequestId 封装新的身份标识，并记录到关联映射中与 downstream 信息组合；&lt;/li&gt;
&lt;li&gt;MOSN 从 upstream(conn=5) 接收了一个响应 response，依据报文扩展多路复用接口 GetRequestId 获取到请求在这条连接上的身份标识(requestId=30)。此时可以从上下游关联映射表中，根据 upstream 信息(connId=5, requestId=30) 找到对应的 downstream 信息(connId=2, requestId=1)；&lt;/li&gt;
&lt;li&gt;依据 downstream request 的信息，调用文扩展多路复用接口 SetRequestId 设置响应的 requestId，并回复给 downstream；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在整个过程中，框架流程依赖的报文扩展 Multiplexing 接口提供的能力，实现了上下游请求的多路复用关联处理，除此之外，框架还封装了很多细节的处理，例如上下游复用内存块合并处理等等，此处限于篇幅不再展开，有兴趣的同学可以参考源码进行阅读。&lt;/p&gt;

&lt;h3 id=&#34;统一路由框架&#34;&gt;统一路由框架&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248786-ff9c157a-5ff9-444b-8b0f-2da90ddb8392.png&#34; alt=&#34;统一路由框架&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来要分析的是「统一路由框架」的设计，此方案主要解决的是非 HTTP 协议的路由适配问题。我们选取了以下三点进行具体分析：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过基于属性匹配(attribute-based)的模式，与具体协议字段解耦；&lt;/li&gt;
&lt;li&gt;引入层级路由的概念，解决属性扁平化后带来的线性匹配性能问题；&lt;/li&gt;
&lt;li&gt;通过变量机制懒加载的特定，按需实现深/浅解包；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;统一路由框架 – 基于属性匹配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248809-fe944cba-e8df-4497-8eff-c8d47131c918.png&#34; alt=&#34;统一路由框架-基于属性匹配&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先来看一下典型的 RDS 配置，可以看到其中的 domains、path 等字段，对应的是 HTTP 协议里的域名、路径概念，这就意味着其匹配条件只有 HTTP 协议才有字段能够满足，配置结构设计是与 HTTP 协议强相关的。这就导致了如果我们新增了一个私有协议，无法复用 RDS 的配置来做路由。&lt;/p&gt;

&lt;p&gt;那么如何解决配置模型与协议字段强耦合呢？简单来说就是把匹配字段拆分为扁平属性的键值对(key-value pair)，匹配策略基于键值对来处理，从而解除了匹配模型与协议字段的强耦合，例如可以配置 &lt;code&gt;key: $http_host&lt;/code&gt;，也可以配置 &lt;code&gt;key:$dubbo_service&lt;/code&gt;，这在配置模型层面都是合法的。&lt;/p&gt;

&lt;p&gt;但是这并不是说匹配就有具体协议无关了，这个关联仍然是存在的，只是从强耦合转换为了隐式关联，例如配置 &lt;code&gt;key: $http_host&lt;/code&gt;，从结构来说其与 HTTP 协议并无耦合，但是值变量仍然会通过 HTTP 协议字段来进行求值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;统一路由框架 -  层级路由&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248832-20483dc3-e959-4cf4-aecd-cbe5ba37b4fb.png&#34; alt=&#34;统一路由框架 -  层级路由&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在引入「基于属性的匹配」之后，我们发现了一个问题，那就是由于属性本身的扁平化，其内在并不包含层级关系。如果没有层级关系，会导致匹配时需要遍历所有可能的情况组合，大量条件的场景下匹配性能近似于线性的 O(n)，这显然是无法接受的。&lt;/p&gt;

&lt;p&gt;举例来说，对于 HTTP 协议，我们总是习惯与以下的匹配步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;匹配 Host(:authority) ；&lt;/li&gt;
&lt;li&gt;匹配 Path ；&lt;/li&gt;
&lt;li&gt;匹配 headers/args/cookies ；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这其实构成了一个层级关系，每一层就像是一个索引，通过层级的索引关系，在大量匹配条件的情况下仍然可以获得一个可接受的耗时成本。但是对于属性(attribute)，多个属性之间并没有天然的层级关系(相比于 host、path 这种字段)，这依赖于属性背后所隐式关联的字段，例如对于 Dubbo 协议，我们希望的顺序可能是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_service&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_group&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_version&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;匹配 &lt;code&gt;$dubbo_attachments_xx&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此在配置模型上，我们引入了对应的索引层级概念，用于适配不同协议的结构化层级路由，解决扁平属性的线性匹配性能问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;统一路由框架 - 浅解包优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1585209248848-77a91fc3-ab6c-4eb8-a62b-3496668d66c3.png&#34; alt=&#34;统一路由框架 - 浅解包优化&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，介绍一下浅解包优化的机制。利用 MOSN 变量懒加载的特性，我们可以在报文解析时，先不去解析成本较高的部分，例如 dubbo 协议的 attachments。那么在代理请求的实际过程中，需要使用到 attachments 里的信息时，就会通过变量的 getter 求值逻辑来进行真正的解包操作。依靠此特性，可以大幅优化在不需要深解包的场景下 dubbo 协议代理转发的性能表现，实现按需解包。&lt;/p&gt;

&lt;h3 id=&#34;解读总结&#34;&gt;解读总结&lt;/h3&gt;

&lt;p&gt;最后，对设计部分的几个技术案例简单总结一下，整体的思路仍然是对处理流程进行抽象封装，并剥离可扩展点，从而降低用户的接入成本。&lt;/p&gt;

&lt;p&gt;在协议扩展支持方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;封装编解码流程，抽象编解码能力接口作为协议扩展点&lt;/li&gt;
&lt;li&gt;封装协议处理流程，抽象多路复用、心跳保活、优雅退出等能力接口作为协议扩展点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在路由框架方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过改为基于属性匹配的机制，与具体协议字段解耦，支持多协议适配；&lt;/li&gt;
&lt;li&gt;引入层级路由机制，解决属性扁平化的匹配性能问题；&lt;/li&gt;
&lt;li&gt;利用变量机制懒加载特性，按需实现深/浅解包；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;后续规划及展望&#34;&gt;后续规划及展望&lt;/h2&gt;

&lt;h3 id=&#34;更多流模式支持-更多协议接入&#34;&gt;更多流模式支持、更多协议接入&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248869-cc2b0d96-1e9c-4e77-8047-d2022dd3dac0.png&#34; alt=&#34;更多流模式支持、更多协议接入&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当前 MOSN 多协议机制，已经可以比较好的支持像 Dubbo、SOFABolt 这样基于多路复用流模型的微服务协议，后续会继续扩展支持的类型及协议，例如经典的 PING-PONG 协议、Streaming 流式协议，也欢迎大家一起参与社区建设，贡献你的 PR。&lt;/p&gt;

&lt;h3 id=&#34;社区标准方案推进&#34;&gt;社区标准方案推进&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;1585209248892-b736ba21-4a23-4f8b-9ba0-7623f7125e72.png&#34; alt=&#34;社区标准方案推进&#34; /&gt;&lt;/p&gt;

&lt;p&gt;与此同时，我们注意到 Istio 社区其实也有类似的需求，希望设计一套协议无关的路由机制——&amp;rdquo;Istio Meta Routing API&amp;rdquo;。其核心思路与 MOSN 的多协议路由框架基本一致，即通过基于属性的路由来替代基于协议字段的路由。目前该草案还处于一个比较初级的阶段，对于匹配性能、字段扩展方面还没有比较完善的设计说明，后续 MOSN 团队会积极参与社区方案的讨论，进一步推动社区标准方案的落地。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: MOSN 扩展机制解析</title>
      <link>https://mosn.io/zh/docs/concept/extensions/</link>
      <pubDate>Thu, 09 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://mosn.io/zh/docs/concept/extensions/</guid>
      <description>
        
        
        

&lt;p&gt;本文将才从以下几个方面介绍 MOSN 的扩展机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MOSN 扩展能力和扩展机制的详细介绍；&lt;/li&gt;
&lt;li&gt;结合示例对 MOSN 的 Filter 扩展机制与插件扩展机制进行详细介绍；&lt;/li&gt;
&lt;li&gt;MOSN 后续扩展能力规划与展望；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本问中的示例在 MOSN 的 Github 的 &lt;code&gt;examples/codes/mosn-extensions&lt;/code&gt; 目录下，大家也可以下载下来运行一下。&lt;/p&gt;

&lt;h3 id=&#34;mosn-简介&#34;&gt;MOSN 简介&lt;/h3&gt;

&lt;p&gt;MOSN 作为云原生的网络代理，旨在为服务提供多协议、模块化、智能化、安全的代理能力。在实际生产使用中，不同的厂商会有不同的使用场景，通用的网络代理能力面对具体的业务场景会显得有些不足，通常都需要进行二次开发以满足业务需求。MOSN 在核心框架中，提供了一系列的扩展机制和扩展点，就是为了满足需要基于业务进行二次开发的场景，同时 MOSN 提供的部分通用逻辑也是基于扩展机制和扩展点的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268765-2c1afc84-0142-4217-b666-0cc9cbdf7e78.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;比如通过 MOSN “内置实现”的透明劫持的能力，就是通过 MOSN Filter 机制实现。而要实现消息的代理，则可以通过类似的扩展实现。在通用代理的情况下，可以通过 Filter 机制实现业务的认证鉴权，也可以实现定制的负载均衡逻辑；除了转发流程可以扩展实现以外，MOSN 还可以扩展日志的实现，用于对标已有的日志系统，也可以扩展 XDS 实现定制的配置更新；根据不同的业务场景还会有很多具体的扩展情况，就不在此展开了，有兴趣的可以关注 MOSN 社区正在建设的源代码分析系列文章与文档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436269068-a0a77749-1a98-4bce-9e9b-323ea3bd14a5.png&#34; alt=&#34;图片 1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MOSN 作为一款网络代理，在转发链路上的网络层、协议层、转发层，在非转发链路上的配置、日志、Admin API 等都提供了扩展能力，对于协议扩展的部分，有兴趣的可以看一下上期直播讲的 &lt;a href=&#34;../multi-protocol&#34;&gt;MOSN 多协议机制解析&lt;/a&gt;，我们今天将重点介绍一下转发层的 Stream Filter 扩展机制与 MOSN 的插件机制。&lt;/p&gt;

&lt;h3 id=&#34;stream-filter-机制&#34;&gt;Stream Filter 机制&lt;/h3&gt;

&lt;p&gt;在实际业务场景中，在转发请求之前或者回写响应之前，都可能需要对请求/响应做一些处理，如判断是否需要进行转发的认证/鉴权，是否需要限流，又或者需要对请求/响应做一些具有业务语义的记录，需要对协议进行转换等。这些场景都与具体的业务高度耦合，是一个典型的需要进行二次开发的情况。MOSN 的 Stream Filter 机制就是为了满足这样的扩展场景所设计的，它也成为目前 MOSN 扩展中使用频率最高的扩展点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268982-8881e2b5-d3a7-443e-ac1f-90735b32f4e9.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在目前的内置 MOSN 实现中，Stream Filter 机制暂时与内置的 network filter: proxy 是绑定的，后面我们也考虑将这部分能力进行抽象，让其他 network filter 也可以复用这部分能力。&lt;/p&gt;

&lt;p&gt;关于 Stream Filter，今天会为大家讲解两个部分的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个 Stream Filter 包含哪些部分以及在 MOSN 中是如何工作的；&lt;/li&gt;
&lt;li&gt;通过一个 Demo 演示来加深对 Stream Filter 的实现与应用；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;一个完整的-stream-filter&#34;&gt;一个完整的 Stream Filter&lt;/h4&gt;

&lt;p&gt;一个完整的 StreamFilter，包含三个部分的内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个 StreamFilter 对象，存在于每一个请求/响应当中，在 MOSN 收到请求的时候发挥作用，我们称为 ReceiverFilter，在 MOSN 收到响应时发挥作用，我们称为 SenderFilter。一个 StreamFilter 可以是其中任意一种，也可以是两种都是；&lt;/li&gt;
&lt;li&gt;一个 StreamFilterFactory 对象，用于 MOSN 在每次收到请求时，生成 StreamFilter 对象。在 Listener 配置解析时，一个 StreamFilter 的配置会生成一个其对于的 StreamFilterFactory。同一个 StreamFilter 在不同的 Listener 下可能对应不同的 StreamFilterFactory，但是也有的特殊情况下，StreamFilterFactory 可能需要实现为单例；&lt;/li&gt;
&lt;li&gt;一个 CreateStreamFilterFactory 方法，配置解析时生成 StreamFilterFactory 就是调用它；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;1586436268990-060fa931-308c-4237-898f-463ce5a3228c.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;stream-filter-在-mosn-中是如何工作的&#34;&gt;Stream Filter 在 MOSN 中是如何工作的&lt;/h4&gt;

&lt;p&gt;接下来，我们看下 Stream Filter 在 MOSN 中是如何工作的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436269017-a78ea077-adea-4e5c-bb19-48843553362d.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当 MOSN 经过协议解析，收到一个完整的请求时，会创建一个 Stream。此时收到请求的 Listener 中每存在 StreamFilterFactory，就会生成一个 StreamFilter 对象，随后进入到 proxy 流程。&lt;/p&gt;

&lt;p&gt;进入 proxy 流程以后，如果存在 ReceiverFilter，那么就会执行对应的逻辑，ReceiverFilter 包括两个阶段，“路由前”和“路由后”，在每个 Filter 处理完成以后，会返回一个状态，如果是 Stop 则会中止后续尚未执行的 ReceiverFilter，通常情况下，返回 Stop 状态的 Filter 都会回写一个响应。如果是 Continue 则会执行下一个 ReceiverFilter，直到本阶段的 ReceiverFilter 都执行完成或中止；路由前阶段的 ReceiverFIlter 执行完成后，就会执行路由后阶段，其逻辑和路由前一致。如果是正常转发，那么随后 MOSN 会收到一个响应或者发现其他异常直接回写一个响应，此时就会进入到 SenderFilter 的流程中，完成 SenderFilter 的处理。SenderFilter 处理完成以后，MOSN 会写响应给 Client，并且完成最后的收尾工作，收尾工作包括一些数据的回收、日志的记录，以及 StreamFilter 的“销毁”（调用 OnDestroy）。&lt;/p&gt;

&lt;h4 id=&#34;stream-filter-demo&#34;&gt;Stream Filter Demo&lt;/h4&gt;

&lt;p&gt;对 StreamFilter 有了一个基本的认识以后，我们来看一个实际的 Demo 代码来看下如何实现一个 StreamFilter 并且让它在 MOSN 中发挥作用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268993-74f02195-c831-4c42-9736-d9eaf7b26cb7.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按照刚才我们的介绍，一个 Stream FIlter 要包含三部分：Filter、Factory、CreateFactory。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先我们实现一个 Filter，其逻辑是模拟一个鉴权的 Filter：只有请求的 Header 中包含所配置的 Key-Value 时，MOSN 才会对请求做继续转发，否则直接返回 403 错误；&lt;/li&gt;
&lt;li&gt;然后我们实现一个 Factory，它负责生成我们实现的 Filter，并且说明 Filter 应该发挥作用的阶段（在请求阶段、路由匹配之前）；&lt;/li&gt;
&lt;li&gt;最后我们定义了一个生成 DemoFactory 的函数 CreateDemoFactory，并且通过 init 将其“注册”，注册完成以后，MOSN 配置解析就可以识别这个 StreamFilter；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;1586436269034-bac1b72c-84cd-48c8-9e73-4867587ee28d.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成实现以后，我们就可以通过具体的配置来实现对应的功能了。在示例的配置中，配置 StreamFilter 为我们刚才实现的 Filter，只转发 Header 中包含 user:admin 的请求。示例配置中监听的端口是 2046，转发的后端 server 端口是 8080。在演示之前，我已经完成了 8080 server 的启动，这个 server 会对收到的任意请求返回 200 。我们来看一下 MOSN 转发情况。Demo 操作可以在文末直播的视频回顾中查看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stream Filter Demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/simple_streamfilter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;mosn-plugin-机制&#34;&gt;MOSN Plugin 机制&lt;/h3&gt;

&lt;p&gt;下面我们来了解一下 MOSN 的 Plugin 机制。&lt;/p&gt;

&lt;p&gt;刚才我们对 Stream Filter 有了一个了解，MOSN 中其余的扩展实现也是类似的方法，思路就是编码实现 MOSN 扩展点所需要的接口然后利用 MOSN 的框架运行扩展的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268983-cccb6022-61e0-491c-8dd6-5d1c67a31d02.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是这里会发现一个问题，就是有时候我们需要的扩展能力已经有现成可用的实现了，那么我们是否可以做简单的改造就让 MOSN 可以获取对应的能力，哪怕目前可用的实现不是 Go 语言的实现，比如现成的限流能力的实现、注入能力的实现等；又或者对于某些特定的能力，它需要有更严格的控制，更高的标准，比如安全相关的能力。&lt;/p&gt;

&lt;p&gt;类似这样的场景，我们引入了 MOSN 的 Plugin 机制，它支持我们可以对 MOSN 需要的能力进行独立开发或者我们对现有的程序进行适当的改造以后，就可以将它们引入到 MOSN 当中来。&lt;/p&gt;

&lt;p&gt;MOSN 的 Plugin 机制包含了两部分内容，一是 MOSN 自定义的 Plugin 框架，它支持通过在 MOSN 中实现 agent 与一个独立的进程进行交互来完成 MOSN 扩展能力的实现。二是基于 Golang 的 Plugin 框架，通过动态库（SO）加载的方式，实现 MOSN 的扩展。其中动态库加载的方式目前还存在一些局限性，还处于 beta 阶段。&lt;/p&gt;

&lt;p&gt;我们先来看一下多进程 Plugin 框架。&lt;/p&gt;

&lt;h4 id=&#34;多进程-plugin-框架&#34;&gt;多进程 Plugin 框架&lt;/h4&gt;

&lt;p&gt;MOSN 的 Plugin 框架是 MOSN 封装的一个可以让 MOSN 通过 gRPC 和独立进程进行交互的方式，它包含两部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;独立的进程通过 MOSN Plugin 框架管理，作为 MOSN 的子进程；MOSN 的 Plugin 框架可以管理它们，如启动、关闭等；&lt;/li&gt;
&lt;li&gt;通过在 MOSN 中实现的 agent，使用 gRPC 的方式和子进程进行交互，gRPC 可以是基于 tcp 的，也可以是基于 domain socket 的；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;1586436268954-38e37509-fbf8-44f4-a0fe-0860401daae0.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;基于这个框架，我们只需要开发或者进行一些改造，让程序满足 MOSN 框架的规范，就可以作为 MOSN 多进程插件的一部分。&lt;/p&gt;

&lt;p&gt;首先我们需要提供一个 gRPC 的服务，并且满足 MOSN 框架下的 proto 定义。当 gRPC server 启动完成以后，向标准输出（stdout）输出一段约定的字符串，作为 MOSN 和子进程之间的握手协议。MOSN 中的对应 agent 会通过握手协议完成与子进程之间的连接建立。握手协议的字符串包含5个字段，每个字段之间用&amp;rdquo;|&amp;ldquo;分割，其中带$符号的是根据实际进程情况需要填写的值，其余的是当前约定的固定字段。network 支持 tcp/unix，代表通过 tcp 方式还是 unix domain socket 的方式进行通信，addr 表示 gRPC server 监听的地址。&lt;/p&gt;

&lt;p&gt;MOSN 提供了 go 语言的子进程 server 封装，在 go 语言场景下，作为子进程的程序只需要实现一个 MOSN 框架下的 plugin.Service 接口，并且通过 plugin.Serve 方法启动即可。&lt;/p&gt;

&lt;p&gt;通过 Plugin 框架，让 MOSN 做到在扩展功能实现的时候，支持隔离性、支持异构语言扩展能力、支持模块化，以及具备进程管理的能力。&lt;/p&gt;

&lt;p&gt;对于 MOSN 通过多进程方式完成扩展，今天准备了两个示例和大家进行分享。一个是基于 MOSN 的 TLS 扩展，模拟了通过一个安全等级比较高的证书管理程序来获取 TLS 配置证书、私钥等敏感信息的能力；第二个是将之前演示的 Stream Filter 修改为了“子进程”，模拟“如何将现成的能力”引入 MOSN。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于 MOSN 的 TLS 扩展示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先来看 TLS 的扩展，示例包含两部分内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;独立的子进程，用 Go 语言实现，实现了 plugin.Service 接口，并通过 plugin.Serve 方法启动；&lt;/li&gt;
&lt;li&gt;MOSN 扩展点实现交互 agent。在这里就不详细展开TLS扩展点的细节了，只关注交互过程：通过 Call 方法发送 gRPC 请求，获取响应，完成相关逻辑；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;1586436269094-79115a60-66ca-4318-9049-82079bae5979.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;load cert demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/cert_loader&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/cert_loader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看一下效果，首先配置依然是监听 2046 的端口，配置了扩展的 TLS 配置，就需要 HTTPS 才可以访问 MOSN。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stream Filter 作为 agent 示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面我们来看下 Stream Filter 作为 agent，与多进程之间的示例，模拟“如何将现成的能力”引入 MOSN。在示例中我们把之前的“鉴权”认为是一个“现成的”能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268973-4fe309cb-83dc-41d8-9bff-0887cf08d68a.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;独立进程中实现和之前一样的“鉴权”能力，其配置来自进程的启动参数。Stream Filter 作为 agent 实现，其中“校验”逻辑修改为和子进程交互，在生成 Factory 时完成子进程的启动和配置设置。&lt;/p&gt;

&lt;p&gt;这个示例运行以后和之前 Stream Filter 的效果是一样的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stream Filter Plugin demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;动态库-so-扩展机制&#34;&gt;动态库(SO)扩展机制&lt;/h4&gt;

&lt;p&gt;在目前的多进程框架中，虽然扩展能力可以通过一个独立的子程序实现，但是仍然需要在 MOSN 中实现一个 agent 用于交互，依然需要在MOSN中编写一部分代码；而我们希望引入动态库（SO）加载的机制，实现在不重新编译 MOSN 的情况下，通过加载不同的 SO，做到不同的扩展能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436268988-2b2d72f0-ce06-4678-ba14-ec1b73bb85a9.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;与子程序模式相比，SO 虽然也是一个独立的二进制，但是最终启动的时候，不会有额外的子进程存在，其生命周期可以和 MOSN 完全保持一致，而且动态库机制还有一个优势：它可以让扩展代码和 MOSN 完全解耦合。&lt;/p&gt;

&lt;p&gt;但是，目前使用动态库加载的方式还存在一些限制，因此 MOSN 对于这个能力也还处于 Beta 阶段，并没有投入实际使用，需要完善。相关的原因包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部分 MOSN 扩展的实现需要用到 MOSN 中的一些定义，因此在动态库实现时不能完全做到解耦合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这个问题，MOSN 将一些基础库（如日志、buffer 等），一些 API 定义从 MOSN 的核心仓库中独立出来，这样扩展实现和 MOSN 核心都引用这些“独立”的库，减少扩展对 MOSN 核心代码的依赖。&lt;/p&gt;

&lt;p&gt;如果某一个扩展点要支持完全解耦合的动态库扩展，那么对应的扩展点都需要进行支持动态库加载的改造，包括配置模型与实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MOSN 动态库加载的方式，其实是基于 Go 语言的 plugin 包实现的，它可以加载用 Go 语言编译的动态库。但是对于动态库的编译环境存在一些限制，编译它时必须和 MOSN 编译时的 GOPATH 保持一致；同时引用的代码路径都需要保持一致，如果存在 vendor 目录，那么意味着编译动态库时的项目路径也得和 MOSN 核心保持一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决这个问题，我们考虑使用 Docker 编译，在编译时统一 GOPATH，强制修改代码目录结构，屏蔽掉 Vendor 目录差异的方式来解决，这种方式目前仍然在验证中。&lt;/p&gt;

&lt;p&gt;因此理论上 MOSN 目前所有的扩展点都可以使用 Go 语言原生机制通过加载 SO 的方式来实现，而目前 MOSN 最适合实现这个能力的一个扩展点就是 Stream Filter。&lt;/p&gt;

&lt;p&gt;我们只需要实现一个通用的、可以加载 SO 的 Filter，然后在具体的 SO 中实现真正的 StreamFilter 逻辑，由于 StreamFilter 实现所需要的接口定义都在 mosn.io/api 中，所以 SO 可以做到和 MOSN 核心框架解耦合。&lt;/p&gt;

&lt;p&gt;关键点就是这个通用 Filter 的设计和实现，我们也通过 Demo 来看一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通用 Filter 的设计和实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个通用的 Filter 和普通的 StreamFilter 不同，它只包含一个要素：CreateFactory。思路是通过通用的 CreateFactory，加载 SO 中的 CreateFactory 并执行，让 SO 中的 Factory 发挥作用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1586436269013-7a2935b1-37f5-45c2-9e96-f11f62ed8bee.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通用 CreateFactory 包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置解析，解析出两部分内容：一是需要加载的 SO 路径，二是 SO 中对应 Filter 所需要的配置；&lt;/li&gt;
&lt;li&gt;SO 路径就代表了 SO 中 Filter 的“注册”，以及本次会选择这个 Filter；&lt;/li&gt;
&lt;li&gt;加载 SO，基于其中约定好的函数名，获取真正的 CreateFactory 函数；&lt;/li&gt;
&lt;li&gt;调用真正的 CreateFactory 函数，实现 SO 中 StreamFilter 的加载；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我们可以看到，SO 中的 StreamFIlter 也和普通的 FIlter 有些区别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成 StreamFilterChainFactory 的函数必须是固定的名字；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不再需要 init “注册”该函数；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stream Filter SO Demo: &lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/so&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/mosn-extensions/plugin/so&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Demo Readme：&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/cn_readme/mosn-extensions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们来看一下这个 Demo 的效果。本次 Demo 中的 Filter 实现依然是之前的“鉴权”示例。经过验证，我们发现这个思路是可行的，但是离生产实践还需要完善更多的细节。&lt;/p&gt;

&lt;h3 id=&#34;代码扩展活动&#34;&gt;代码扩展活动&lt;/h3&gt;

&lt;p&gt;经过这些演示，相信大家对 MOSN 的扩展能力也有所了解了，这里我们来做一个代码扩展活动，希望大家可以踊跃参与。完成活动任务，提交相关代码 PR 到 MOSN 的仓库，我们会进行 CodeReview 和验证，第一个验证通过的代码将合并到 MOSN 的 example 中，并且对提交的同学送上一份奖励；对于前3名提交、同样结果正确并且是原创的，虽然我们不能合并对应的代码，但是我们也将送上奖励。&lt;/p&gt;

&lt;p&gt;活动任务共有五个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多进程 Demo 中证书加载的独立进程，使用 python 或者 java 实现以后，demo 运行演示成功。任意一种语言就算完成一个任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/cert_loader/python/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/cert_loader/java/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多进程 Demo 中 stream filter 的独立进程，使用 python 或者 java 实现以后，demo 运行演示成功。任意一种语言就算完成一个任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/filter/python/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/filter/java/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SO 动态加载 Demo 中，SO 里实现的 Stream Filter 结合多进程框架（GO 语言）实现，Demo 运行演示成功。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;examples/codes/mosn-extensions/plugin/so/subprocess/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;跨语言相关的实现可以参考以下示例：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mosn/mosn/tree/master/examples/codes/plugin/across-languages/server/&#34; target=&#34;_blank&#34;&gt;https://github.com/mosn/mosn/tree/master/examples/codes/plugin/across-languages/server/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;规划与展望&#34;&gt;规划与展望&lt;/h3&gt;

&lt;p&gt;最后向大家介绍一下 MOSN 后续扩展能力的规划，也希望大家有需求的可以向我们反馈，有兴趣的一起参与到 MOSN 的建设中来。首先就是要完善 SO 动态库加载机制，让 MOSN 支持 SO 方式加载扩展；然后就是针对 LUA 的脚本扩展以及支持 WASM 的扩展能力；最后 MOSN 还会增加更多的扩展点，以满足更多更复杂的场景。非常欢迎大家参与到 MOSN 社区的共建中。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
